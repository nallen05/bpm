<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
 <head>
   <title>BPM: pattern matching for Common Lisp</title>
   <link rel="stylesheet" type="text/css" href="style.css"/>
 <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>
</head>




<body>
 <div class="header">
  <h1>BPM</h1>
  <h2>Pattern Matching for Common Lisp
 </div>

 <h3>Overview</h3>

 <p>BPM is a simple pattern matching library for Common Lisp.</p>

 <h3>Download</h3>

<p>Download the latest gzipped tarball:</p>

<ul>
  <li><a href="bpm_0.1.tar.gz">Version 0.1</a> 4.11.2007</li>
</ul>

<p>or get the latest version from the <a href="http://darcs.net">darcs</a> repo:</p>

<p><pre class="code">darcs get http://common-lisp.net/project/bpm/darcs/bpm</pre></p>

<p>you can get specific releases like this, too</p>

<p><pre class="code">darcs get --tag "0.1" http://common-lisp.net/project/bpm/darcs/bpm</pre></p>

<p>BPM is also <a href="http://cliki.net/ASDF-Install">ASDF-Installable</a>:</p>

<pre class="code">(asdf-install:install 'bpm)</pre>

<h3>License</h3>

<p><a href="http://en.wikipedia.org/wiki/BSD_License">BSD</a></p>

<h3>Supported Implementations</h3>

<p>BPM is written in portable Common Lisp, so it should run on all implimentations. Run `bpm-test.lisp' (included in the tarball) if you feel you need to.</p>

<h3>A Bird's Eye View of BPM</h3>

<p><a href="#match"><code>MATCH</code></a> is like <a href="http://www.lisp.org/HyperSpec/Body/mac_casecm_ccasecm_ecase.html"><code>CASE</code></a> except it uses pattern matching instead of keys and it executes success forms within the <a href="http://www-cgi.cs.cmu.edu/Groups/AI/util/html/cltl/clm/node43.html">lexical scope</a> of the matched pattern.</p>

<p><a href="#def"><code>DEF!</code></a> and <a href="#def"><code>DEF</code></a> allow you to write lisp functions in pattern matching style.</p>

<p><a href="#bpm-lambda"><code>BPM-LAMBDA</code></a> is a pattern matching <a href="http://www.lisp.org/HyperSpec/Body/sym_lambda.html"><code>LAMBDA</code></a>.</p>

<p><a href="#arrow"><code>-&gt;</code></a> and <a href="#arrow"><code>--&gt</code></a> are self-evaluating constants provided as syntactic spice to help make pattern matching forms more readable.</p>

<p><a href="#create-bpm-compiler"><code>CREATE-BPM-COMPILER</code></a> is the low-level reification of everything BPM has to offer. It can safely be ignored if your not implementing your own domain specific syntactic abstractions or logic system on top of BPM.</p>

<h3>Pattern Matching</h3>

<p>BPM uses "S-Expression Patterns" to match sexps. S-Expression Patterns are sexps that may or may not contain logic variables.</p>

<p>The following sexps are s-expression patterns:</p>

<pre class="code">
   5
   nil
   (a . b)
</pre>

<p>They do not have any logic variables and they match the sexps:</p>

<pre class="code">
   5
   nil
   (a . b)
</pre>

<p>respectively.</p>

<p>By default, <a href="#create-bpm-compiler"><code>CREATE-BPM-COMPILER</code></a> recognises any symbol starting with <code>_</code> (the underscore) as a logic variable. In the pattern</p>

<pre class="code">
   (foo . _bar)
</pre>

<code>_BAR</code> is a logic variable. This pattern matches:

<pre class="code">
   (foo)
   (foo 1)
   (foo 1 2)
   (foo 1 2 4)
   (foo . anything)
   <i>...etc...</i>
</pre>

<p>In fact it matches any list with <code>foo</code> as its first element. Within the respective scope of these matches, _BAR would be bound to</p>

<pre class="code">
   NIL
   (1)
   (1 2)
   (1 2 3)
   anything
   <i>...etc...</i>
</pre>

<p>The variable <code>_</code> (just the underscore) is the "wildcard". It is a special variable that can match anything and never remembers what it's bound to. So the pattern</p>

<pre class="code">
   (_ _ _)
</pre>

<p>matches any list of the length 3, and <code>_</code> isn't bound to anything within the scope of this match.</p>

<p>BPM also matches/destructure simple vectors, so</p>

<pre class="code">
   #(_1 _1 _2 _2)
</pre>

<p>matches a simple vector of length 4 whose first two elements are the same and last two elements are the same.</p>

<p><b>Caveat</b>: It is not immediately assumed that <code>_1</code> != <code>_2</code>. So this pattern matches</p>

<pre class="code">
  (a a a a)
</pre>

<p>and</p>

<pre class="code">
  (b b b b)
</pre>

<p>as well as</p>

<pre class="code">
  #(a a b b)
</pre>

<p><b>Note</b>: you can use a <a href="#where"><code>WHERE</code></a> or <a href="where"><code>WHERE-NOT</code></a> clauses within <a href="#def"><code>DEF!</code></a>/<a href="#def"><code>DEF</code></a> or <a href="match"><code>MATCH</code></a> forms to give your matches arbitrary constraints such as <code>(not (eql _1 _2))</code>.</p>

<h3>Equality</h3>

<p><a href="#create-bpm-matcher"><code>CREATE-BPM-MATCHER</code></a> uses <code>EQL</code> as the default equality test. This can be overwritten by rebinding <a href="#logic-var-equality-test"><code>*LOGIC-VAR-EQUALITY-TEST*</code></a> during bpm-compile-time.</p>

<h3>Changing the Syntax</h3>

<p><a href="#create-bpm-matcher"><code>CREATE-BPM-MATCHER</code></a>'s syntax is slightly flexible. see <a href="#logic-var-prefix-char"><code>*LOGIC-VAR-PREFIX-CHAR*</code></a>, <a href="#logic-var-pred"><code>*LOGIC-VAR-PRED*</code></a>, <a href="#logic-var-wildcard-pred"><code>*LOGIC-VAR-WILDCARD-PRED*</code></a>, and <a href="#destructure-simple-vectors-p"><code>*DESTRUCTURE-SIMPLE-VECTORS-P*</code></a>.</p>

<h3>API</h3>

<div class="def" >
 <p><span>macro</span><br/> <code><a name="match"></a><b>MATCH</b> (form &amp;clauses))</code></p>
</div>
 <div class="desc">
   <p><code>MATCH</code> is like <a href="http://www.lisp.org/HyperSpec/Body/mac_casecm_ccasecm_ecase.html"><code>CASE</code></a> except it uses sexp patterns instead of keys and success forms are executed within the lexical scope of their respective matches.</p>

<pre class="code">
cl-user> (match '(1 2)
	   ((_h . _t) -&gt; (format nil "list with a head of ~A and a tail of ~A" _h _t))
	   (_x -&gt; (format nil "~A is an atom" _x)))
"list with a head of 1 and a tail of (2)"

cl-user> (match 3
	   ((_h . _t) -&gt; (format nil "list with a head of ~A and a tail of ~A" _h _t))
	   (_x -&gt; (format nil "~A is an atom" _x)))
"3 is an atom"
</pre>

  <p><code>MATCH</code> clauses can optionally take an arbitrary number of <a href="#where"><code>WHERE</code></a> and <a href="#where"><code>WHERE-NOT</code></a> clauses.</p>

</div>

<div class="def">
  <p><span>macros</span><br/>
     <code><a name="def"></a><b>DEF!</b> (name pattern &amp;body body)</code><br/>
     <code><b>DEF</b> (name pattern &amp;body body)</code>
  </p>
</div>

<div class="desc">

<p><code>DEF!</code> is like <code>DEFUN</code> except it takes an s-expression pattern instead of a lambda list. The created function takes one argument: if that argument matches <code>PATTERN</code>, then the function executes <code>BODY</code> within the scope of the match. Otherwise it simply returns <code>NIL</code>.</p>

<pre class="code">
cl-user&gt; (def! foo (_x . _y)
             -&gt; (cons _y _x))
foo
cl-user&gt; (foo '(1 . 2))
(2 . 1)
cl-user&gt; (foo 1)
nil
</pre>

  <p><code>DEF</code> adds additional pattern matching clauses to functions defined with <code>DEF!</code>. A <code>DEF</code>! form can be thought of as the first clause to a <a href="#match"><code>MATCH</code></a> where subsequent <code>DEF</code> forms are subsequent <a href="#match"><code>MATCH</code></a> clauses.</p>

<pre class="code">
cl-user&gt; (def foo _ -&gt; 'not-a-cons)
foo
cl-user&gt; (foo '(1 2 3))
((2 3) . 1)
cl-user&gt; (foo 1)
not-a-cons
</pre>

  <p>Both <code>DEF!</code> and <code>DEF</code> can optionally have an arbitrary number of <a href="#where"><code>WHERE</code></a> and <a href="#where"><code>WHERE-NOT</code></a> clauses in <code>BODY</code>.</p>
</div>


<div class="def">
  <p><span>symbols</span><br/>
     <code><a name="where"></a><b>WHERE</b> (test)</code><br/>
     <code><b>WHERE-NOT</b> (test)</code>
  </p>
</div>

<div class="desc">

<p>The symbols <code>WHERE</code> and <code>WHERE-NOT</code> act as special keywords when seen inside <a href="#match"><code>MATCH</code></a> clauses or <a href="#def"><code>DEF!</code></a>/<a href="#def"><code>DEF</code></a> bodies.</p>

<p><code>WHERE</code> and <code>WHERE-NOT</code> can be thought of as functions that take a single argument (<code>TEST</code>): when <code>WHERE</code> or <code>WHERE-NOT</code> forms appear immediatly after a sexp pattern, a match against that pattern is not considered successful unless all the <code>WHERE</code> arguments evaluate to a non-<code>NIL</code> values and the <code>WHERE-NOT</code> arguments evaluate to <code>NIL</code>.</p>

<p><b>Note:</b> <code>WHERE</code> and <code>WHERE-NOT</code> clauses are "short-circuiting" (like an <code>AND</code>).</p>

<pre class="code">
(match request
  (#(_user _a) (where (find-user _user))
           --&gt; (do-user-actions _a))
  (_req    --&gt; (error 'bad-request :request _req)))

(def! get-username #(_id _node)

  ;; validate node
  (where (node? _node))
  (where (node-exists? _node))

  ;; find username 
  (.get-username _id _node))

(def get-username #(_id _node)
  (error 'bad-node :node _node))

(def get-username _req
  (error 'bad-request :request _req))
</pre>

</div>

<div class="def">
  <p><span>macro</span><br/> <code><b><a name="bpm-lambda"></a>bpm-lambda</b> (pattern &amp;body body)</code></p>
</div>

<div class="desc">

<p><code>BPM-LAMBDA</code> is just like <code>LAMBDA</code> except that it takes an s-expression pattern as a first argument instead of a lambda list.</p>

<p>The resultant function takes one argument: if that argument matches <code>PATTERN</code> then the function executes <code>BODY</code> within the lexical scope of the match. Otherwise it simply returns <code>NIL</code>.</p>

<p><b>Caveat:</b> <code>BPM-LAMBDA</code> does not understand <code>WHERE</code> or <code>WHERE-NOT</code> clauses</p>

</div>


<div class="def">
  <p><span>function</span><br/><code><a name="create-bpm-compiler"></a><b>create-bpm-compiler</b> (pattern &amp;optional bound)</code>
  </p>
</div>

<div class="desc">

<p><code>CREATE-BPM-COMPILER</code> takes an s-expression pattern and a list of already bound logic variables. It returns a function (<code>FUNCTION1</code>) and a new list of logic variables.</p>

<p>This new function takes a piece of unevaluated lisp code and returns the source of a new unary function (<code>FUNCTION2</code>). If <code>FUNCTION2</code>'s argument matches <code>PATTERN</code>, then <code>FUNCTION2</code> executes the lisp code given to <code>FUNCTION2</code> within the lexical scope of the match. Otherwise it simply returns <code>NIL</code>.</p>

<p><code>BPM-LAMBDA</code> can be implemented as:</p>

<pre class="code">
(defmacro bpm-lambda (pattern &amp;body body)
  (funcall (create-bpm-compiler pattern) `(progn ,@body)))
</pre>

<p><code>CREATE-BPM-COMPILER</code>'s second return value is the accumulated list of logic variables that will be bound within <code>FUNCTION2</code>'s evuation of the lisp form given as an argument to <code>FUNCTION1</code>. This list can be given as the argument to <code>CREATE-BPM-COMPILER</code>'s optional <code>BOUND</code> argument in recursive calls to <code>CREATE-BPM-MATCHER</code>: in this way it is possible to create nested pattern matchers that are lexically aware of the pattern matching environment around them.</p>

<pre class="code">
cl-user&gt; (create-bpm-compiler '(1 _1 #(_1 _2) _2))
#&lt;Closure (:internal create-bpm-compiler 1) @ #x10719da2&gt;
(_2 _1)

cl-user&gt; (funcall * '(progn (print _1) (print _2)))
(lambda (#:g6249)
  (declare (dynamic-extent #:g6249))
  (and (listp #:g6249)
       (eql (first #:g6249) '1)
       (let ((#:g6252 (rest #:g6249)))
         (declare (dynamic-extent #:g6252))
         (if (listp #:g6252)
             (let ((_1 (first #:g6252))
		   (#:g6255 (rest #:g6252)))
               (declare (dynamic-extent #:g6255))
               (if (listp #:g6255)
                   (let ((#:g6257 (first #:g6255)))
                     (declare (dynamic-extent #:g6257))
                     (and (simple-vector-p #:g6257)
                          (= (length #:g6257) 2)
                          (eql (svref #:g6257 0) _1)
                          (let ((_2 (svref #:g6257 1))
                                (#:g6261 (rest #:g6255)))
                            (declare (dynamic-extent #:g6261))
                            (and (listp #:g6261)
                                 (eql (first #:g6261) _2)
                                 (not (rest #:g6261))
                                 (progn (print _1)
					(print _2))))))))))))

cl-user&gt; (funcall (coerce * 'function) '(1 one #(one two) two))
"one"
"two"
</pre>

</div>

<div class="def">
  <p><span>variable</span><br/> <a name="logic-var-prefix-char"></a><code><b>*LOGIC-VAR-PREFIX-CHAR*</b></code></p>
</div>

<div class="desc">
<p>The character that indicates logic and wildcard variables. Initially set to <code>#\_</code>.</p>
</div>

<div class="def">
  <p><span>variable</span><br/> <a name="logic-var-pred"></a><code><b>*LOGIC-VAR-PRED*</b></code></p>
</div>

<div class="desc">
<p>A unary predicate that returns <code>T</code> if its argument is a logic variable. Initially set to a function that looks for symbols whose names start with <a href="#logic-var-prefix-char"><code>*LOGIC-VAR-PREFIX-CHAR*</code></a></p>
</div>

<div class="def">
  <p><span>variable</span><br/> <a name="logic-var-wildcard-pred"></a><code><b>*LOGIC-VAR-WILDCARD-PRED*</b></code></p>
</div>

<div class="desc">
<p>A unary predicate that returns <code>T</code> if its argument is a logic var wildcard. Initially set to a function that looks for symbols with the name <a href="#logic-var-prefix-char"><code>*LOGIC-VAR-PREFIX-CHAR*</code></a></p>
</div>

<div class="def">
  <p><span>variable</span><br/> <a name="destructure-simple-vectors-p"></a><code><b>*DESTRUCTURE-SIMPLE-VECTORS-P*</b></code></p>
</div>

<div class="desc">
<p>Initially set to <code>T</code>. Bind this to <code>NIL</code> if you want vectors to be seen as atomic objects in your s-expression patterns</p>
</div>

<div class="def">
  <p><span>variable</span><br/> <a name="logic-var-equality-test"></a><code><b>*LOGIC-VAR-EQUALITY-TEST*</b></code></p>
</div>

<div class="desc">
<p>Lambda form or name of function that tests whether or not s-expressions match parts of an s-expression pattern. Initially set to <code>EQL</code>.</p>
</div>

<div class="def">
  <p><span>constants</span><br/> <a name="arrow"></a><code><b>-&gt;</b></code><br/>
                                 <code><b>--&gt;</b></code>
  </p>
</div>

<div class="desc">
<p>Syntactic spice. These self-evaluating constants exist only to help make your code more visually intuitive.</p>
</div>

 <h3>Mailing Lists</h3>
 <ul>
  <li>
   <a
    href="http://www.common-lisp.net/mailman/listinfo/bpm">
    bpm-devel</a><br/>for developers</li>
  <li>
   <a
    href="http://www.common-lisp.net/mailman/listinfo/bpm-function-announce">
    bpm-announce</a><br/>for announcements.</li>
    <li>
    email the author/maintainer (Nick Allen) directly at nallen05@&lt;first-letter-of-Google&gt;mail.com</li>    
 </ul>

 </body>
</html>
